import Professional from "../models/professional.model.js";
import Appointment from "../models/appointment.model.js";
import {calculateBaseSchedules} from "../utils/validationUtils.js";
import moment from "moment";
import "moment/locale/es.js"; // Importa el idioma español

moment.locale("es"); // Configura el idioma a español


// Create a new professional
export const createProfessional = async (req, res, next) => {
    try {
        const { nombre, apellido, especialidad, dias_laborales, horarios_laborales } = req.body;

        const newProfessional = new Professional({ nombre, apellido, especialidad, dias_laborales, horarios_laborales });
        await newProfessional.save();

        res.status(201).json({ message: "Profesional creado exitosamente", profesional: newProfessional });
    } catch (error) {
        next(error); // Handle errors generated by model validations
    }
};

export const getProfessionalById = async (req, res, next) => {
    try {
        const { profesionalId } = req.params;

        // Buscar el profesional por ID
        const professional = await Professional.findById(profesionalId);

        if (!professional) {
            return res.status(404).json({ message: "Profesional no encontrado" });
        }

        res.status(200).json(professional);
    } catch (error) {
        next(error);
    }
};

// Get all specialties
export const getSpecialties = async (req, res, next) => {
    try {
        // Use `distinct` to get a unique list of specialties
        const specialties = await Professional.distinct("especialidad");

        res.status(200).json(specialties);
    } catch (error) {
        next(error);
    }
};

// Get professionals by specialty
export const getProfessionalsBySpecialty = async (req, res, next) => {
    try {
        // Decodificar la especialidad para manejar caracteres especiales
        const { especialidad } = req.params;
        const decodedEspecialidad = decodeURIComponent(especialidad);

        // Buscar profesionales por especialidad
        const professionals = await Professional.find({ especialidad: decodedEspecialidad });

        // Verificar si se encontraron resultados
        if (professionals.length === 0) {
            return res.status(404).json({ message: "No se encontraron profesionales para esta especialidad" });
        }

        // Responder con los profesionales encontrados
        res.status(200).json(professionals);
    } catch (error) {
        // Manejar errores
        next(error);
    }
};


// Get available schedules for a professional on a specific date
export const getAvailableSchedules = async (req, res, next) => {
    try {
        const { profesionalId } = req.params;
        const { fecha } = req.query;

        // Validar que se haya proporcionado una fecha
        if (!fecha) {
            return res.status(400).json({ message: "La fecha es obligatoria para obtener los horarios disponibles" });
        }

        // Validar el formato de la fecha
        if (!moment(fecha, "YYYY-MM-DD", true).isValid()) {
            return res.status(400).json({ message: "El formato de la fecha debe ser YYYY-MM-DD" });
        }

        const professional = await Professional.findById(profesionalId, "dias_laborales horarios_laborales");
        if (!professional) {
            return res.status(404).json({ message: "Profesional no encontrado" });
        }

        // Obtener el día de la semana de la fecha proporcionada en español
        let dayOfWeek = moment(fecha).format("dddd"); // Ejemplo: "miércoles"

        // Convertir la primera letra a mayúscula para que coincida con el enum
        dayOfWeek = dayOfWeek.charAt(0).toUpperCase() + dayOfWeek.slice(1);

        // Verificar si el día de la semana está en los días laborales del profesional
        if (!professional.dias_laborales.includes(dayOfWeek)) {
            return res.status(400).json({ message: `El profesional no trabaja el día ${dayOfWeek}` });
        }

        // Calcular los horarios base
        const baseSchedules = calculateBaseSchedules(professional.horarios_laborales);

        // Buscar citas existentes para el profesional en la fecha proporcionada, solo las que están "Agendadas"
        const appointments = await Appointment.find({
            profesional: profesionalId,
            fecha,
            estado: "Agendado" // Filtrar solo las citas que están agendadas
        });

        // Obtener los horarios ocupados
        const occupiedSchedules = appointments.map(appointment => appointment.hora);

        // Filtrar los horarios disponibles
        const availableSchedules = baseSchedules.filter(schedule => !occupiedSchedules.includes(schedule));

        res.status(200).json(availableSchedules);
    } catch (error) {
        next(error);
    }
};


// Update a professional
export const updateProfessional = async (req, res, next) => {
    try {
        const { profesionalId } = req.params;
        const { nombre, apellido, especialidad, dias_laborales, horarios_laborales } = req.body;

        const professional = await Professional.findById(profesionalId);
        if (!professional) {
            return res.status(404).json({ message: "Profesional no encontrado" });
        }

        professional.nombre = nombre || professional.nombre;
        professional.apellido = apellido || professional.apellido;
        professional.especialidad = especialidad || professional.especialidad;
        professional.dias_laborales = dias_laborales || professional.dias_laborales;
        professional.horarios_laborales = horarios_laborales || professional.horarios_laborales;

        await professional.save();

        res.status(200).json({ message: "Profesional actualizado exitosamente", profesional: professional });
    } catch (error) {
        next(error);
    }
};

// Delete a professional
export const deleteProfessional = async (req, res, next) => {
    try {
        const { profesionalId } = req.params;

        const professional = await Professional.findById(profesionalId);
        if (!professional) {
            return res.status(404).json({ message: "Profesional no encontrado" });
        }

        await Professional.findByIdAndDelete(profesionalId);

        res.status(200).json({ message: "Profesional eliminado exitosamente" });
    } catch (error) {
        next(error);
    }
};

